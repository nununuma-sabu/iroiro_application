# permutations（順列生成コマンド）

概要
- このディレクトリには、コマンドライン引数として与えた整数列の全順列を辞書順（lexicographic order）で列挙する C プログラム `permutation_cmd.c` が含まれます。
- 出力として各順列を表示し、総件数と処理時間を表示します。

使用方法

1. コンパイル（例: POSIX 環境）
   ```sh
   gcc -std=c99 -O2 permutation_cmd.c -o permutation_cmd
   ```

2. 実行
   ```sh
   ./permutation_cmd 1 2 3
   ```

   - 引数は列挙する要素（整数）を空白で区切って与えます。
   - プログラムは引数の個数を N として扱います（argv[1] ... argv[N]）。

実行例（出力イメージ）
```
--- Start Permutations (N=3) ---
1 2 3 
1 3 2 
2 1 3 
2 3 1 
3 1 2 
3 2 1 
--- End ---
Total Permutations: 6
Processing Time   : 0.000123 sec
```

入力制約
- プログラム内で N>13 の場合に警告を出します。理由は N! の爆発的増加のためで、実行時間や出力量が非常に大きくなるためです。

アルゴリズムの説明

- 全体の方針
  - 入力配列をまず昇順にソートし（`qsort`）、辞書順で最小の順列から開始します。
  - 「次の辞書順順列」を生成する関数 `next_permutation` を繰り返し呼び出して全順列を列挙します。

- next_permutation の手順（単一反復）
  1. 右端から左に走査して、最初に arr[i] < arr[i+1] を満たす位置 i を見つける（これが pivot）。
     - そのような i が見つからない場合、配列は完全降順でありこれが最後の順列なので終了する（関数は false を返す）。
  2. 右端から左へ走査して、最初に arr[j] > arr[i] を満たす位置 j を見つける。
  3. arr[i] と arr[j] を交換する（swap）。
  4. i+1 から末尾までの区間を反転（reverse）して、suffix を最小（昇順）に戻す。
  5. これにより辞書順で次に大きい順列が得られる（関数は true を返す）。

- なぜ正しいか（短い説明）
  - pivot 位置を選ぶことで、現在の順列よりも大きくかつ最小の位置で変化させる箇所を決め、交換と suffix の反転でその後の部分を最小化するため、辞書順の次が得られます。

計算量・メモ
- 生成される順列数は N!（N は要素数）。
- next_permutation の各反復コストは最悪 O(N)（pivot 探索・交換・反転）。よって全列挙は O(N * N!)。
- メモリは主に入力配列の O(N)（追加の大きな補助配列は不要）。

実装上のポイント
- `compare_ints`: `qsort` 用の比較関数（昇順ソート）。
- `swap` / `reverse`: 配列操作の補助関数。
- `generate_permutations`: 初期ソート後に順列を列挙してカウントするドライバ。
- `main` で実行時間を `clock()` により計測して表示。

注意事項
- 出力をファイルにリダイレクトすると非常に大きなファイルになる可能性があるため、ディスク容量に注意してください。
  ```sh
  ./permutation_cmd 1 2 3 4 > perms.txt
  ```
- ランダムな順列がほしい場合は辞書順列挙ではなく Fisher–Yates（Knuth）シャッフルを使用してください。

付録
- README を英語訳する、Makefile を追加する、あるいは N が大きい場合にサンプリングするスクリプトを追加することもできます。必要であれば作成します。
